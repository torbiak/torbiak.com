<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jordan Torbiak</title>
    <link>http://torbiak.com/index.xml</link>
    <description>Recent content on Jordan Torbiak</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 29 Sep 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://torbiak.com/index.xml" rel="self" type="application/rss+xml" />
    
      
    <item>
      <title>Revisiting pruned approaches</title>
      <link>http://torbiak.com/post/revisiting_pruned_approaches/</link>
      <pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/revisiting_pruned_approaches/</guid>
      <description>&lt;p&gt;Recently I&amp;rsquo;ve noticed a few cases where I&amp;rsquo;ve been solving a problem and determined that some approach doesn&amp;rsquo;t work, only to get stuck on other approaches too and finally return to the supposedly broken approach and realize that it actually works. Occasionally I&amp;rsquo;ll explicitly set out to rewrite a piece of broken code using the same approach and it&amp;rsquo;ll work and I can compare the two, but for most problems the history will be gone and I&amp;rsquo;m left wondering what I was doing wrong before.&lt;/p&gt;

&lt;p&gt;This doesn&amp;rsquo;t only happen for programming problems, either. I was searching through my journal looking for something else yesterday and happened to see an unsuccessful skin-care regime I undertook about a year ago. It called for the use of two products and I followed it for a week but it worsened my skin&amp;rsquo;s condition so much that I stopped. A few months ago I started using one of the products alone, having completely forgotten about my prior experience, and it proved super effective. I likely could have seen those results a year earlier if I&amp;rsquo;d changed one variable at a time and hadn&amp;rsquo;t conflated the failure of the combo with the failure of each individually.&lt;/p&gt;

&lt;p&gt;These false negatives for good approaches aren&amp;rsquo;t surprising: I fail to solve many problems on the first try even when I&amp;rsquo;m using an approach that&amp;rsquo;s been shown by others to work. And when it&amp;rsquo;s unclear why something is broken, as it often is, it&amp;rsquo;s easy to get the impression that the approach is hopeless without having enough information to confidently rule it out. The best strategy I can think of to mitigate the cost of these false negatives is to take better notes. I often take notes of the approaches I&amp;rsquo;m trying, but clearly I need to be more disciplined in noting why I abandon an approach as well so I can judge later whether I did so mistakenly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;See also&lt;/strong&gt;: Nelson Elhage&amp;rsquo;s &lt;a href=&#34;https://blog.nelhage.com/2010/06/lab-notebooking-for-the-software-engineer/&#34;&gt;Lab Notebooking for the Software Engineer&lt;/a&gt;, which gave more purpose to my existing notetaking habit.&lt;/p&gt;
</description>
    </item>
      
    
      
    <item>
      <title>Histograms of timestamped data: gnuplot vs matplotlib</title>
      <link>http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/</link>
      <pubDate>Sun, 16 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;I wanted to learn a charting tool that is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;convenient enough to quickly create rough data visualizations without it feeling like an indulgent digression&lt;/li&gt;
&lt;li&gt;fast enough to visualize large datasets, maybe millions of points&lt;/li&gt;
&lt;li&gt;scriptable, so chart source code plays well with version control&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Without doing much research on the options I decided to start with the venerable gnuplot. Data I&amp;rsquo;ve needed to analyze at previous jobs have always been time series or event streams, so I chose visualizing my bash history as a practice task. After working through a series of charts of increasing sophistication with gnuplot I started worrying that other tools might be more convenient, so I replicated my gnuplot journey with matplotlib. In the end my worries were unfounded and I&amp;rsquo;m actually pretty happy with gnuplot, especially for quick-and-dirty jobs. matplotlib certainly has some advantages, like having a popular, sensible language like Python as its interface, and possibly being an alternative to R when used along with &lt;a href=&#34;http://pandas.pydata.org/pandas-docs/stable/index.html&#34;&gt;pandas&lt;/a&gt;, but gnuplot&amp;rsquo;s brevity is difficult to resist.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been disappointed with the resources I&amp;rsquo;ve found for charting timestamped data in both gnuplot and matplotlib, motivating me to share my experience.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re less interested in the progression and just want to see how I&amp;rsquo;d recommend making a chart like the below from a timestamped log, skip &lt;a href=&#34;#multiple-distributions-stacked-bars&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_stackedbars.svg&#34; alt=&#34;shellhist_gp_stackedbars.svg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-data&#34;&gt;The data&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m examining my &lt;code&gt;bash&lt;/code&gt; history to see when I&amp;rsquo;ve been most active over the past couple days. To get some data we can set &lt;code&gt;HISTTIMEFORMAT&lt;/code&gt; so &lt;code&gt;bash&lt;/code&gt;&amp;rsquo;s &lt;code&gt;history&lt;/code&gt; command annotates entries with timestamps:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ HISTTIMEFORMAT=&amp;quot;%Y-%m-%dT%H:%M:%S &amp;quot; history &amp;gt;shellhist
$ tail shellhist
10215  2017-07-01T09:52:36 make dist
10216  2017-07-01T09:52:40 git tag
10217  2017-07-01T09:52:44 git tag v0.002003
10218  2017-07-01T09:52:57 cpan-upload -u TORBIAK App-Git-Autofixup.tar.gz
10219  2017-07-01T09:53:08 git push
10220  2017-07-01T09:53:13 git push --tags
10221  2017-07-01T09:53:31 make realclean
10222  2017-07-01T09:53:36 rm App-Git-Autofixup-0.002003.tar.gz
10223  2017-07-01T09:53:38 fg
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;gnuplot&#34;&gt;gnuplot&lt;/h1&gt;

&lt;h2 id=&#34;a-rough-start-points&#34;&gt;A rough start: points&lt;/h2&gt;

&lt;p&gt;To get a rough visualization of when commands were entered we can tell gnuplot we&amp;rsquo;re dealing with time data on the x-axis by setting &lt;code&gt;xdata time&lt;/code&gt; and &lt;code&gt;timefmt&lt;/code&gt; and plot each command as a point, spreading the points across the y-axis at random to make it easier to get a sense of their density. gnuplot interprets &lt;code&gt;using 2:(rand(0))&lt;/code&gt; to mean that we&amp;rsquo;re using the second column of &lt;code&gt;shellhist&lt;/code&gt; for the x-values, and random floats in the interval [0:1] as the y-values. The parentheses around &lt;code&gt;rand(0)&lt;/code&gt; are necessary to signal that we want to use the value of an expression instead of selecting a column from the data file.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:using&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:using&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_points.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set xdata time
set timefmt &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;
plot &#39;shellhist&#39; using 2:(rand(0)) with points
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Plot the script from the gnuplot prompt with &lt;code&gt;load &#39;shellhist_gp_points.gp&#39;&lt;/code&gt; or using a shell command like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GNUTERM=svg gnuplot shellhist_gp_points.gp &amp;gt;shellhist_gp_points.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_points.svg&#34; alt=&#34;shellhist_gp_points.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;binning-times&#34;&gt;Binning times&lt;/h2&gt;

&lt;p&gt;The above chart gives a rough idea of when I was executing commands, but it&amp;rsquo;d be interesting to get more specific and quantify how many commands I was running per hour or minute. To do that we need to put entries in bins, mapping the command timestamps to intervals of the desired length. If we&amp;rsquo;re glancing at the manual we might think that the &lt;code&gt;histograms&lt;/code&gt; plotting style does what we want, but it doesn&amp;rsquo;t: it expects data to already be binned. We need to bin the data some other way; we could use a different tool or programming language, or we can use the &lt;code&gt;smooth frequency&lt;/code&gt; modifier for gnuplot&amp;rsquo;s &lt;code&gt;using&lt;/code&gt; clause, which adds ups the y-values for each unique x-value encountered.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:smooth&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:smooth&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; So if we can get the time values as &lt;a href=&#34;https://en.wikipedia.org/wiki/Unix_time&#34;&gt;epoch seconds&lt;/a&gt;, round them to the start of the interval&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:leap&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:leap&#34;&gt;3&lt;/a&gt;&lt;/sup&gt; they&amp;rsquo;re in, and set the y-values as &lt;code&gt;1.0&lt;/code&gt;, then &lt;code&gt;smooth frequency&lt;/code&gt; will add up those ones, creating the needed mapping of interval start times to number of commands executed.&lt;/p&gt;

&lt;p&gt;gnuplot represents times as epoch seconds&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:time-repr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:time-repr&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; and since we&amp;rsquo;ve set &lt;code&gt;timefmt&lt;/code&gt; and &lt;code&gt;xdata time&lt;/code&gt; we might expect that referencing column 2 in the expression for the x-values would evaluate to epoch seconds, but it actually follows the usual behaviour and evaluates to the first number present in the field, 2017 in our case. We&amp;rsquo;ve specified that xdata is time-based, not that column 2 is only to be interpreted as a time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# WRONG. $2 evaluates to 2017, not epoch seconds.
set xdata time
set timefmt &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;
binwidth = 3600
plot &#39;shellhist&#39; using ($2 - ($2 % binwidth)):(1.0) with impulses
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead we use the &lt;code&gt;timecolumn&lt;/code&gt; function to get epoch seconds as a float. Most of the time we can rely on type coercion but to use the modulus (&lt;code&gt;%&lt;/code&gt;) operator &lt;code&gt;t&lt;/code&gt; needs to be converted to an int. Since &lt;code&gt;timecolumn&lt;/code&gt; takes a format there&amp;rsquo;s no need to set &lt;code&gt;timefmt&lt;/code&gt; anymore. Also, we can avoid parsing the date twice and make the script more readable by defining a user-defined function we&amp;rsquo;ll call &lt;code&gt;bin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_line.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set xdata time

binwidth = 3600 # 1h in seconds
bin(t) = (t - (int(t) % binwidth))

plot &#39;shellhist&#39; using (bin(timecolumn(2, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;))):(1.0) \
    smooth freq with linespoints
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_line.svg&#34; alt=&#34;`shellhist_gp_line.svg`&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;discontinuities&#34;&gt;Discontinuities&lt;/h2&gt;

&lt;p&gt;If we look closely at the chart above there&amp;rsquo;s a discontinuity on June 28, from 1 to ~30. This is due to multiline commands in my shell history: lines after the first don&amp;rsquo;t match the column specification given in the &lt;code&gt;using&lt;/code&gt; clause and column 1 for these lines ends up being interpreted as &lt;code&gt;NaN&lt;/code&gt;, resulting in a discontinuity in the data and multiple points being drawn for the same time interval. Instead of filtering the data with a separate script it was easier to ignore these lines using &lt;code&gt;set datafile missing NaN&lt;/code&gt;. Sometimes discontinuities are easier to notice when plotted with the &lt;code&gt;boxes&lt;/code&gt; plot style, where they show up as multiple lines within a box.&lt;/p&gt;

&lt;h2 id=&#34;improve-readability&#34;&gt;Improve readability&lt;/h2&gt;

&lt;p&gt;If we wanted to share this chart there&amp;rsquo;s a number of other worthwhile improvements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Add a title.&lt;/li&gt;
&lt;li&gt;Hide the legend (&amp;ldquo;key&amp;rdquo; in gnuplot parlance), which is more distracting than useful in this case.&lt;/li&gt;
&lt;li&gt;Include time of day in the x-axis labels.&lt;/li&gt;
&lt;li&gt;Remove extraneous xtics, ytics, and border lines, depending on our preference.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Histograms are commonly plotted using boxes, which is particularly nice when the boxes cover the x-axis intervals they represent. By default boxes are centered on their x-value, so we need to change the &lt;code&gt;bin&lt;/code&gt; function to offset them slightly. Also, we&amp;rsquo;ll need to set &lt;code&gt;boxwidth&lt;/code&gt;, since by default adjacent boxes are extended until they touch.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_bars.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;binwidth = 3600 # 1h in seconds
bin(t) = (t - (int(t) % binwidth) + binwidth/2)

set xdata time
set datafile missing NaN

set boxwidth binwidth

set xtics format &amp;quot;%b %d %H:%M&amp;quot; time rotate
set xtics nomirror
set ytics nomirror
set key off
set border 1+2 # Set the bits for bottom and left borders.
set title &#39;Commands Run Per Hour&#39;

plot &#39;shellhist&#39; using (bin(timecolumn(2, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;))):(1.0) \
    smooth freq with boxes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_bars.svg&#34; alt=&#34;shellhist_gp_bars.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;multiple-distributions-with-lines&#34;&gt;Multiple distributions with lines&lt;/h2&gt;

&lt;p&gt;Plotting multiple distributions with lines is only slightly trickier. For this data plotting all possible series would clutter the chart severely, so we instead find the most frequent commands using gnuplot&amp;rsquo;s &lt;code&gt;system&lt;/code&gt; function and a pipeline and only plot those. Then we use the &lt;code&gt;plot&lt;/code&gt; command&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; clause to iterate over the data for each of the top commands, binning each separately by using ternary operator in the using clause to count one command per iteration.&lt;/p&gt;

&lt;p&gt;If a line is missing columns then &lt;code&gt;stringcolumn(3)&lt;/code&gt; will evaluate to &lt;code&gt;NaN&lt;/code&gt; and a type error will be thrown when comparing it as a string to &lt;code&gt;cmd&lt;/code&gt;. To avoid this we can clean up the file or use &lt;code&gt;valid&lt;/code&gt; to check that a line has usable fields. &lt;code&gt;valid&lt;/code&gt; only checks that columns aren&amp;rsquo;t &lt;code&gt;NaN&lt;/code&gt;, though, so we can&amp;rsquo;t use it on string columns, as I was initially tempted to. &lt;code&gt;valid(3)&lt;/code&gt; is always false since a string that don&amp;rsquo;t contain numbers converts to &lt;code&gt;NaN&lt;/code&gt; when coerced to a float.&lt;/p&gt;

&lt;p&gt;While I don&amp;rsquo;t want to plot all the series for the sake of readability, I would like to know how many command executions aren&amp;rsquo;t covered by the top few, so I&amp;rsquo;ve also plotted a line showing the overal number of commands run per hour. As shown in the last line of the example the previous datafile given to a &lt;code&gt;plot&lt;/code&gt; command can be reused by specifying the empty string (&lt;code&gt;&#39;&#39;&lt;/code&gt;),&lt;/p&gt;

&lt;p&gt;Most gnuplot command names and modifiers can be abbreviated as long as they&amp;rsquo;re unambiguous, and I&amp;rsquo;ve taken advantage of this by writing &lt;code&gt;u&lt;/code&gt; instead of &lt;code&gt;using&lt;/code&gt; for the first &lt;code&gt;plot&lt;/code&gt; clause to help reduce the line length. Abbreviations are regularly used in examples I&amp;rsquo;ve seen on the web.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_stackedlines.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fmt = &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;

binwidth = 3600 # 1h in seconds
bin(t) = (t - (int(t) % binwidth) + binwidth/2)

set xdata time
set datafile missing NaN

set xtics format &amp;quot;%b %d %H:%M&amp;quot; time rotate nomirror
set ytics nomirror
set border 1+2 # Set the bits for bottom and left borders.
set title &#39;Commands Run Per Hour&#39;


top_cmds = system(&amp;quot;awk &#39;$3 ~ /^[a-zA-Z0-9_-]+$/{print $3}&#39; shellhist \
    | sort | uniq -c | sort -rn | awk &#39;{print $2}&#39; | sed 10q&amp;quot;)

plot for [cmd in top_cmds] &#39;shellhist&#39; \
    u (bin(timecolumn(2, fmt))):((valid(1) &amp;amp;&amp;amp; strcol(3) eq cmd) ? 1 : NaN) \
        smooth freq with lines title cmd, \
    &#39;&#39; using (bin(timecolumn(2, fmt))):(1.0) \
        smooth freq with lines title &amp;quot;sum&amp;quot; dashtype &#39;..&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_stackedlines.svg&#34; alt=&#34;shellhist_gp_stackedlines.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;multiple-distributions-with-stacked-bars&#34;&gt;Multiple distributions with stacked bars&lt;/h2&gt;

&lt;p&gt;Plotting distributions using lines is convenient when making the chart, but if many distributions are involved the chart gets uncomfortably busy. Plotting the chart with stacked bars can make it easier to read.&lt;/p&gt;

&lt;h3 id=&#34;inline-transformations&#34;&gt;Inline transformations&lt;/h3&gt;

&lt;p&gt;Here we&amp;rsquo;re using a similar approach as for the previous chart, using gnuplot expressions to transform the data so it&amp;rsquo;s suitable for use with &lt;code&gt;smooth frequency&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The main complication is that we need to stack the bars ourselves, plotting sums of comamnd frequencies in descending order so taller bars don&amp;rsquo;t completely obscure the short ones. To acheive that we plot the sum of a decreasing number of commands using a &lt;code&gt;sum&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:sum&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:sum&#34;&gt;5&lt;/a&gt;&lt;/sup&gt; expression. Each box will obscure just the bottom of the previous one, with the unobscured portion&amp;mdash;that is, the difference between the sums&amp;mdash;representing the frequency of the command.&lt;/p&gt;

&lt;p&gt;There are some minor changes, too, like the formatting options for the boxes, and setting the xtics to be &lt;code&gt;out&lt;/code&gt; so they aren&amp;rsquo;t obscured by the boxes. Also, since the series with the smallest overall frequencies are plotted first so they&amp;rsquo;re at the top of the stack, I&amp;rsquo;ve explicitly chosen which linetypes to use with &lt;code&gt;linetype cmd&lt;/code&gt; (&lt;code&gt;cmd&lt;/code&gt; being used as a linetype index) so the nicer colours at the start of the sequence are used for the biggest boxes.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_stackedbars.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;binwidth = 3600 # 1h in seconds
bin(t) = (t - (int(t) % binwidth) + binwidth/2)

set xdata time
set datafile missing NaN
set boxwidth binwidth
set xtics format &amp;quot;%b %d %H:%M&amp;quot; time rotate out nomirror
set ytics nomirror
set style fill solid border lc rgb &amp;quot;black&amp;quot;
set border 3
set title &amp;quot;Commands run per hour&amp;quot;

top_cmds = system(&amp;quot;awk &#39;$3 ~ /^[a-zA-Z0-9_-]+$/{print $3}&#39; shellhist \
    | sort | uniq -c | sort -rn | awk &#39;{print $2}&#39; | sed 10q&amp;quot;)

time = &#39;(bin(timecolumn(2, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;)))&#39;

plot for [cmd=words(top_cmds):1:-1] &#39;shellhist&#39; \
    u @time:(!valid(1) ? NaN : sum [i=1:cmd] strcol(3) eq word(top_cmds, i)) \
    smooth freq w boxes t word(top_cmds, cmd) linetype cmd, \
    &#39;&#39; u @time:(valid(1)) smooth freq w lines t &#39;sum&#39; dashtype &#39;..&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_stackedbars.svg&#34; alt=&#34;shellhist_gp_stackedbars.svg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;external-reshaping&#34;&gt;External reshaping&lt;/h3&gt;

&lt;p&gt;An alternative method is to reshape the data using some other tool so gnuplot&amp;rsquo;s histogram plot style can be used. For this data this approach is a lot more work than using inline transformations, but there are certainly situations where it&amp;rsquo;s appropriate.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re taking the data from this shape:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;time        cmd
&amp;lt;timestamp&amp;gt; sed
&amp;lt;timestamp&amp;gt; awk
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;time  sed awk
&amp;lt;bin&amp;gt;   0   5
&amp;lt;bin&amp;gt;   5   2
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was almost able to reshape the data with &lt;a href=&#34;http://johnkerl.org/miller/doc/index.html&#34;&gt;&lt;code&gt;mlr&lt;/code&gt;&lt;/a&gt; but ended up using perl. It&amp;rsquo;s mostly a matter of counting frequencies per command for each bin, sorting the commands by frequency using a &lt;a href=&#34;https://en.wikipedia.org/wiki/Schwartzian_transform&#34;&gt;Schwartzian transform&lt;/a&gt; so it&amp;rsquo;s easy to print the top N commands, and then printing out all the bins. See the &lt;a href=&#34;#appendix-pandas&#34;&gt;appendix about pandas&lt;/a&gt; for a far more concise way to do this.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bin.pl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings FATAL =&amp;gt; &#39;all&#39;;

use Time::Piece;
use List::Util qw(sum0 min max);

my $bin_width = 3600;

my %bins;
my %cmd_seen;
for my $line (&amp;lt;&amp;gt;) {
    my ($index, $time_str, $cmd) = split &#39; &#39;, $line;
    next if $cmd !~ /^[a-zA-Z0-9_-]+$/;
    my $time = Time::Piece-&amp;gt;strptime($time_str, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;);
    my $interval = $time-&amp;gt;epoch() - $time-&amp;gt;epoch() % $bin_width;
    $bins{$interval}{$cmd}++;
    $cmd_seen{$cmd}++;
}

my %total_for;
for my $bin (values %bins) {
    for my $cmd (keys %{$bin}) {
        $total_for{$cmd} += $bin-&amp;gt;{$cmd};
    }
}
my @cmds = map {$_-&amp;gt;[0]}
           sort {$b-&amp;gt;[1] cmp $a-&amp;gt;[1]} # hi to lo
           map {[$_, $total_for{$_}]}
           keys %total_for;

my $ofs = &#39; &#39;;
print join($ofs, &#39;time&#39;, &#39;sum&#39;, @cmds), &amp;quot;\n&amp;quot;;

my ($start, $end) = (min(keys %bins), max(keys %bins));
for (my $interval = $start; $interval &amp;lt;= $end; $interval += $bin_width) {
    my @row;
    push @row, gmtime($interval)-&amp;gt;strftime(&amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;);
    push @row, sum0(values %{$bins{$interval}});
    for my $cmd (@cmds) {
        push @row, $bins{$interval}{$cmd} // 0;
    }
    print join($ofs, @row), &amp;quot;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Producing data like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl bin.pl shellhist | tee shellhist_binned
time sum gnuplot fg qiv man go less perl vim echo dicedist cat history find printf ls sort wc meh cd nl tac mv rm sed ll uniq pf wget mkdir help reset seq for
2017-06-27T20:00:00 10 0 0 0 5 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2017-06-27T21:00:00 11 0 0 0 1 0 0 3 2 1 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2017-06-27T22:00:00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2017-06-27T23:00:00 2 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
2017-06-28T00:00:00 10 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 1 0 0 0 0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the &lt;code&gt;histogram&lt;/code&gt; plot type can be used. First off, we&amp;rsquo;ll &lt;code&gt;set style histogram rowstacked&lt;/code&gt; to get stacked bars instead of the default clustered bars, which don&amp;rsquo;t work well with a large number of bins like we have here.&lt;/p&gt;

&lt;p&gt;The x-axis labels require a different approach from before. Lines of histogram data are implicitly plotted at x = 1, 2, 3, etc., so &lt;code&gt;set xdata time&lt;/code&gt; isn&amp;rsquo;t applicable and the data needs to contain all the bins we want plotted, including empty ones. If the times in the datafile aren&amp;rsquo;t in the presentation format desired, the x-axis tick labels can be formatted by giving an &lt;code&gt;xticlabels()&lt;/code&gt; specification in the &lt;code&gt;using&lt;/code&gt; clause and parsing and reformatting the dates using the &lt;code&gt;strptime&lt;/code&gt; and &lt;code&gt;strftime&lt;/code&gt; functions. Since the x-axis range doesn&amp;rsquo;t represent times we need to use &lt;code&gt;xticlabels()&lt;/code&gt; to get useful labels from the data itself. Unfortunately, this means there won&amp;rsquo;t be automatically-spaced major ticks, which are required for the automatic placement of minor ticks, and placing minor ticks manually is tricky. They can be placed using &lt;code&gt;set for x[&amp;lt;start&amp;gt;:&amp;lt;end&amp;gt;:&amp;lt;incr&amp;gt;] xtics add (&#39;&#39; x 1)&lt;/code&gt;, but if an increment greater than 1 is used care must be taken to set the start so the minor ticks are aligned with the major ones, unless the data happens to start at a bin that&amp;rsquo;s a multiple of the increment. For example, if we&amp;rsquo;re using hour-long bins, major ticks are at midnight and noon, the first line of data (x=0) is for 8 o&amp;rsquo;clock, and we want a minor tick every 3 hours, we need to start the minor ticks at x=1&amp;mdash;9 o&amp;rsquo;clock&amp;mdash;instead, not at x=0, and calculating this programmatically is awkward. Alternatively, we can fake minor ticks by placing major ticks without labels, giving the empty string to &lt;code&gt;xticlabels()&lt;/code&gt; at appropriate positions.&lt;/p&gt;

&lt;p&gt;The second plot clause prints the overall command frequency stored in the &lt;code&gt;sum&lt;/code&gt; column and takes care of the xticlabels. Since the rest of the columns are command frequencies sorted in decreasing order we can easily plot the top N commands by changing the iteration conditions of the first clause.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_gp_histogram.gp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Autotitle series in the key using columnheaders from the data file.
set key autotitle columnheader

set style histogram rowstacked
set style fill solid border lc rgb &amp;quot;black&amp;quot;

set xtics nomirror rotate out

set title &amp;quot;Commands run per hour&amp;quot;

xlabel(time) = ( \
    t = strptime(&amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;, time), \
    int(tm_hour(t)) % 12 == 0  ? strftime(&amp;quot;%b %d %H:00&amp;quot;, t) \
    : int(tm_hour(t)) % 3 == 0 ? &#39;&#39; \
    :                            NaN \
)

topN = 10
plot for [i=3:(3+topN-1)] &#39;shellhist_binned&#39; using i with histogram, \
    &#39;&#39; u &amp;quot;sum&amp;quot;:xtic(xlabel(strcol(1))) w lines dashtype &#39;..&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_gp_histogram.svg&#34; alt=&#34;shellhist_gp_histogram.svg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;matplotlib&#34;&gt;matplotlib&lt;/h1&gt;

&lt;h2 id=&#34;dates-times-and-timezones&#34;&gt;Dates, times, and timezones&lt;/h2&gt;

&lt;p&gt;matplotlib includes some convenient date-handling code, particularly for locating and formatting axis ticks, but if we want to take advantage of this we need to give matplotlib our dates in its own format, a float representing the number of days since 0001-01-01 in UTC. Because the format is in UTC and timezone-na√Øve &lt;a href=&#34;https://docs.python.org/3.7/library/datetime.html#datetime-objects&#34;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; assume the local timezone, any &lt;code&gt;datetime.datetime&lt;/code&gt; objects converted using &lt;code&gt;matplotlib.dates.date2num&lt;/code&gt; must be either timezone-aware or in UTC themselves.&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;datetime&lt;/code&gt; module provides the &lt;a href=&#34;https://docs.python.org/3.7/library/datetime.html#datetime.tzinfo`&#34;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; interface to add timezone information to &lt;code&gt;datetime.datetime&lt;/code&gt; instances, but only provides a concrete implementation for simple timezone offsets that don&amp;rsquo;t take DST or other changes into account. Also, &lt;code&gt;datetime.datetime.strptime&lt;/code&gt; can only parse timezone offsets formatted as &lt;code&gt;[-+]HHMM&lt;/code&gt;. For other cases additional libraries will likely be needed. In particluar, if timezone abbreviations are being parsed other libraries like &lt;code&gt;dateutil&lt;/code&gt;, a dependency of matplotlib, can be used to help disambiguate them, seeing as there are &lt;a href=&#34;https://www.timeanddate.com/time/zones/&#34;&gt;many collisions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also, unless we want to display UTC times in our charts we need to give a timezone to matplotlib to use for formatting. We can change matplotlib&amp;rsquo;s runtime configuration setting by giving an &lt;a href=&#34;https://en.wikipedia.org/wiki/Zoneinfo&#34;&gt;Olson&lt;/a&gt; timezone name in our &lt;a href=&#34;http://matplotlib.org/users/customizing.html&#34;&gt;&lt;code&gt;matplotlibrc&lt;/code&gt;&lt;/a&gt; file, or we can override the rc value in code by using &lt;code&gt;matplotlib.rcParams&lt;/code&gt; or by passing an object that implements the &lt;a href=&#34;https://docs.python.org/3.6/library/datetime.html#tzinfo-objects&#34;&gt;&lt;code&gt;datetime.tzinfo&lt;/code&gt;&lt;/a&gt; interface to all our &lt;a href=&#34;http://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Locator&#34;&gt;&lt;code&gt;Locator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://matplotlib.org/api/ticker_api.html#matplotlib.ticker.Formatter&#34;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; objects.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:tzlocal&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:tzlocal&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;  I&amp;rsquo;d rather not override anyone&amp;rsquo;s settings, so I&amp;rsquo;ve just set &lt;code&gt;timezone: America/Edmonton&lt;/code&gt; in my &lt;code&gt;~/.config/matplotlib/matplotlibrc&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;points&#34;&gt;Points&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with the same type of chart as with gnuplot, a point for each command executed, randomly-scattered from [0,1] across the y-axis. This gives a rough idea of when commands were executed. Getting the data out of the &lt;code&gt;shellhist&lt;/code&gt; file is straight-forward but verbose compared to gnuplot, and numpy is convenient for generating a large array of random y-values. Note I&amp;rsquo;ve been careful to convert the &lt;code&gt;datetime.datetime&lt;/code&gt; objects resulting from parsing times to Unix time in UTC before converting them to matplotlib&amp;rsquo;s time representation.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:diyfmt&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:diyfmt&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_mpl_points.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from datetime import datetime
import matplotlib.pyplot as plt
from matplotlib.dates import epoch2num
import numpy as np

times = []
for line in open(&#39;shellhist&#39;):
    fields  = line.split()
    if len(fields) &amp;lt; 3:
        continue
    _, time_str, cmd = fields[:3]
    unixtime = datetime.strptime(time_str, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;).timestamp()
    times.append(epoch2num(unixtime))

fig, ax = plt.subplots()
fig.autofmt_xdate() # Rotate and right-align xtic labels.

ax.plot_date(times, np.random.rand(len(times)), &#39;+&#39;)

plt.savefig(&#39;shellhist_mpl_points.svg&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_mpl_points.svg&#34; alt=&#34;shellhist_mpl_points.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;binning-times-1&#34;&gt;Binning times&lt;/h2&gt;

&lt;p&gt;matplotlib doesn&amp;rsquo;t have anything like gnuplot&amp;rsquo;s &lt;code&gt;smooth frequency&lt;/code&gt; filter (AFAIK), making it less convenient to do a quick-and-dirty line chart. It seems necessary to preprocess the data before plotting it. I looked at using numpy&amp;rsquo;s &lt;code&gt;histogram&lt;/code&gt; function or &lt;code&gt;matplotlib.axes.Axes.hist&lt;/code&gt; but it seems easier to count the frequency per bin using a &lt;code&gt;defaultdict&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For bin widths that evenly divide a day, timestamps are most easily binned when represented as Unix time since every day is defined to have exactly 86400 seconds &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16&#34;&gt;according to POSIX&lt;/a&gt; regardless of leap seconds and it&amp;rsquo;s easy to use the modulus operator, &lt;code&gt;%&lt;/code&gt;, on an integer to find the start of some number of seconds, minutes, or hours. Wheras rounding &lt;code&gt;datetime.datetime&lt;/code&gt; instances seems to require cascading through the different units, and rounding matplotlib&amp;rsquo;s days-since-0001-01-01 representation involves dealing with floats, which are tricky to compare or round reliably and thus a bad choice for dictionary keys.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_mpl_binned_overall.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from collections import defaultdict
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from matplotlib.dates import epoch2num

bin_width = timedelta(hours=1)

freq_for = defaultdict(lambda: 0)
for line in open(&#39;shellhist&#39;):
    fields  = line.split()
    if len(fields) &amp;lt; 3:
        continue
    _, time_str, cmd = fields[:3]
    unixtime = datetime.strptime(time_str, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;).timestamp()
    bin_start = unixtime - unixtime % bin_width.seconds
    freq_for[bin_start] += 1


unixtimes = list(sorted(freq_for.keys()))
times = [epoch2num(t) for t in unixtimes]
freqs = [freq_for[bin] for bin in unixtimes]

fig, ax = plt.subplots()
fig.autofmt_xdate()

ax.plot_date(times, freqs, linestyle=&#39;-&#39;)

plt.savefig(&#39;shellhist_mpl_overall_line.svg&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_mpl_overall_line.svg&#34; alt=&#34;shellhist_mpl_overall_line.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;improve-readability-1&#34;&gt;Improve readability&lt;/h2&gt;

&lt;p&gt;Assuming we liked how the gnuplot single-distribution line chart was styled, we can create a similar chart in matplotlib.&lt;/p&gt;

&lt;p&gt;First, use &lt;code&gt;DateFormatter&lt;/code&gt; and &lt;code&gt;HourLocator&lt;/code&gt; objects instead of &lt;code&gt;Figure.autofmt_xdate&lt;/code&gt; to choose xtick placement and labels:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;format the xtick labels as &amp;ldquo;Jan DD HHHH&amp;rdquo; and only label midnight and noon&lt;/li&gt;
&lt;li&gt;add minor xticks every 3 hours&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hide the top and right &amp;ldquo;spines&amp;rdquo;, as matplotlib calls the &lt;code&gt;Axes&lt;/code&gt; borders&lt;/li&gt;
&lt;li&gt;rotate the xticklabels to vertical. It&amp;rsquo;s harder to read the label itself but clearer which point on the axis the label refers to.&lt;/li&gt;
&lt;li&gt;add a title&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;shellhist_mpl_binned_overall_nicer.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from collections import defaultdict
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
from matplotlib.dates import epoch2num, DateFormatter, HourLocator

bin_width = timedelta(hours=1)

freq_for = defaultdict(lambda: 0)
for line in open(&#39;shellhist&#39;):
    fields  = line.split()
    if len(fields) &amp;lt; 3:
        continue
    _, time_str, cmd = fields[:3]
    unixtime = datetime.strptime(time_str, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;).timestamp()
    bin_start = unixtime - unixtime % bin_width.seconds
    freq_for[bin_start] += 1


unixtimes = list(sorted(freq_for.keys()))
times = [epoch2num(t) for t in unixtimes]
freqs = [freq_for[bin] for bin in unixtimes]

fig, ax = plt.subplots()

plt.xticks(rotation=&#39;vertical&#39;)
ax.spines[&#39;right&#39;].set_visible(False)
ax.spines[&#39;top&#39;].set_visible(False)
ax.xaxis.set_major_formatter(DateFormatter(&amp;quot;%b %d %H00&amp;quot;))
ax.xaxis.set_major_locator(HourLocator(byhour=range(0, 24, 12)))
ax.xaxis.set_minor_locator(HourLocator(byhour=range(0, 24, 3)))
ax.set_title(&amp;quot;Commands Run Per Hour&amp;quot;)

ax.plot_date(times, freqs, linestyle=&#39;-&#39;)

plt.savefig(&#39;shellhist_mpl_overall_line_nicer.svg&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_mpl_overall_line_nicer.svg&#34; alt=&#34;shellhist_mpl_overall_line_nicer.svg&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;multiple-distributions&#34;&gt;Multiple distributions&lt;/h2&gt;

&lt;p&gt;In matplotlib we can work from the same binned data whether we&amp;rsquo;re plotting lines or bars so I&amp;rsquo;m generating both from the same script here. The script is pretty long so I&amp;rsquo;ve organized it into functions.&lt;/p&gt;

&lt;p&gt;Binning is mostly the same as before, except we&amp;rsquo;re filtering out commands that don&amp;rsquo;t look like words using a regular expression and using nested &lt;code&gt;defaultdict&lt;/code&gt;s to also keep track of per-command frequency.&lt;/p&gt;

&lt;p&gt;The styling code in &lt;code&gt;save_chart&lt;/code&gt; is almost the same as before, except &lt;code&gt;Axes.legend&lt;/code&gt; is called between plotting all the series and saving the figure, since it generates a legend based on the series that have already been plotted.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve set the line/bar colours to be &lt;code&gt;tab10&lt;/code&gt; using &lt;code&gt;Axes.set_prop_cycle&lt;/code&gt; in &lt;code&gt;save_chart&lt;/code&gt; just to show one way to change to them. &lt;a href=&#34;http://matplotlib.org/examples/color/color_cycle_demo.html&#34;&gt;This example&lt;/a&gt; show some other ways. &lt;code&gt;tab10&lt;/code&gt; is the default colour cycle, so it&amp;rsquo;s not actually doing anything.&lt;/p&gt;

&lt;p&gt;Plotting lines is straightforward, but plotting stacked bars requires a few extra steps. As with gnuplot we&amp;rsquo;ve offset the times by half a &lt;code&gt;bin_width&lt;/code&gt; and set the bar width so the bars cover the time interval on the x-axis they represent instead of being centered over it.  Also, we need to keep track of the where to plot the bottom of the bars and add the frequencies of each series to it; a numpy array is convenient and efficient for this since operations on an array apply to all of its elements.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellhist_mpl_multi.py&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from collections import defaultdict, namedtuple
from cycler import cycler
from datetime import datetime, timedelta
from matplotlib.dates import epoch2num, DateFormatter, HourLocator
import matplotlib.pyplot as plt
import numpy as np
import re

# cmds: list of command names in decreasing order
# unix_times: bin start times
# freqs_for: dict of command names to numpy arrays of bin frequencies
# totals: numpy array of overall command frequencies for each bin
# bin_width: bin width as datetime.timedelta
CmdFreq = namedtuple(&#39;CmdFreq&#39;,
    [&#39;cmds&#39;, &#39;unix_times&#39;, &#39;freqs_for&#39;, &#39;totals&#39;, &#39;bin_width&#39;])

plt.rcParams[&#39;image.cmap&#39;] = &#39;tab10&#39;

def save_chart(plot_func, data, filename):
    fig, ax = plt.subplots()

    plt.xticks(rotation=&#39;vertical&#39;)
    ax.spines[&#39;right&#39;].set_visible(False)
    ax.spines[&#39;top&#39;].set_visible(False)
    ax.xaxis.set_major_formatter(DateFormatter(&amp;quot;%b %d %H00&amp;quot;))
    ax.xaxis.set_major_locator(HourLocator(byhour=range(0, 24, 12)))
    ax.xaxis.set_minor_locator(HourLocator(byhour=range(0, 24, 3)))
    ax.set_prop_cycle(cycler(&#39;color&#39;, plt.get_cmap(&#39;tab10&#39;).colors))
    ax.set_title(&amp;quot;Commands Run Per Hour&amp;quot;)

    plot_func(ax, data)

    ax.legend() # Called after all data has been plotted.

    plt.savefig(filename)

def plot_bars(axes, data):
    bar_offset = data.bin_width.seconds/2
    offset_times = [epoch2num(t + bar_offset) for t in data.unix_times]
    bar_width = data.bin_width.seconds / 86400.0 # Fraction of a day.

    axes.plot(offset_times, data.totals,
        linestyle=&#39;--&#39;, linewidth=0.4, label=&#39;sum&#39;)

    bottom = np.zeros(len(offset_times))
    for cmd in data.cmds[:10]:
        axes.bar(offset_times, data.freqs_for[cmd],
            bottom=bottom, width=bar_width, label=cmd)
        bottom += data.freqs_for[cmd]

def plot_lines(axes, data):
    float_times = [epoch2num(t) for t in data.unix_times]
    axes.plot(float_times, data.totals,
        linestyle=&#39;--&#39;, linewidth=0.4, label=&#39;sum&#39;)

    for cmd in data.cmds[:10]:
        axes.plot(float_times, data.freqs_for[cmd], label=cmd)


def get_cmd_data(bin_width):
    with open(&#39;shellhist&#39;) as shellhist:
        bin_for, bin_total_for = bin_cmds(shellhist, bin_width)

    cmds = cmds_in_decreasing_freq(bin_for)

    unix_times = np.array(sorted(bin_for.keys()), int)

    freqs_for = {}
    for cmd in cmds:
        freqs_for[cmd] = np.array([bin_for[t][cmd] for t in unix_times])

    totals = np.array([bin_total_for[t] for t in unix_times])

    return CmdFreq(cmds, unix_times, freqs_for, totals, bin_width)

def bin_cmds(event_lines, bin_width):
    bin_for = defaultdict(lambda: defaultdict(lambda: 0))
    bin_total_for = defaultdict(lambda: 0)
    for line in event_lines:
        fields  = line.split()
        if len(fields) &amp;lt; 3:
            continue
        _, time_str, cmd = fields[:3]

        if not re.search(r&#39;^[a-zA-Z0-9_-]+$&#39;, cmd):
            continue

        date = datetime.strptime(time_str, &amp;quot;%Y-%m-%dT%H:%M:%S&amp;quot;)
        unixtime = int(date.timestamp())
        bin_start = unixtime - unixtime % bin_width.seconds

        bin_for[bin_start][cmd] += 1
        bin_total_for[bin_start] += 1

    return bin_for, bin_total_for

def cmds_in_decreasing_freq(bin_for):
    freq_for = defaultdict(lambda: 0)
    for bin_ in bin_for.values():
        for cmd, freq in bin_.items():
            freq_for[cmd] += freq
    pairs = sorted(freq_for.items(), key=lambda pair: pair[1])
    return list(reversed([p[0] for p in pairs]))

if __name__ == &#39;__main__&#39;:
    data = get_cmd_data(timedelta(hours=1))
    save_chart(plot_bars, data, &#39;shellhist_mpl_stacked_bars.svg&#39;)
    save_chart(plot_lines, data, &#39;shellhist_mpl_stacked_lines.svg&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_mpl_stacked_bars.svg&#34; alt=&#34;shellhist_mpl_stacked_bars.svg&#34; /&gt;
&lt;img src=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_mpl_stacked_lines.svg&#34; alt=&#34;shellhist_mpl_stacked_lines.svg&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;best-resources-for-learning&#34;&gt;Best resources for learning&lt;/h1&gt;

&lt;p&gt;For gnuplot I&amp;rsquo;d definitely recommend looking at &lt;a href=&#34;https://www.manning.com/books/gnuplot-in-action-second-edition&#34;&gt;Gnuplot in Action&lt;/a&gt;, which is an amazing tutorial that teaches all the basics and a bunch of practical tricks. If you don&amp;rsquo;t want to buy a book I&amp;rsquo;d recommend reading &lt;a href=&#34;http://gnuplot.info/docs_5.0/gnuplot.pdf&#34;&gt;the manual&lt;/a&gt;, skimming less relevant sections but paying particular attention to most of part 1 and the description of the &lt;code&gt;plot&lt;/code&gt; command in part 3. Once these fundamental topics are understood I think the rest can be looked up as needed. At first glance the manual doesn&amp;rsquo;t look like it&amp;rsquo;s organized for a linear read but I was well-served by that approach. The &lt;code&gt;help&lt;/code&gt; command seems to provide all the content in the manual but conveniently indexed by topic and command, and I wish that I realized how good it was earlier, as I&amp;rsquo;m finding it far more convenient than referring to the manual. Looking through the collection of &lt;a href=&#34;http://gnuplot.sourceforge.net/demo_5.0/&#34;&gt;demos&lt;/a&gt; may also be helpful.&lt;/p&gt;

&lt;p&gt;I learned what I know about matplotlib by stumbling through the official docs, which was painful and inefficient. They&amp;rsquo;re clearly written and comprehensive but it was difficult to find what I needed to do practical things. I suspect having such comprehensive API docs creates a &lt;a href=&#34;https://www.jwz.org/doc/worse-is-better.html&#34;&gt;Worse is Better&lt;/a&gt; situation making the creation of tutorial-style documentation seem like a relatively low-value activity since all the needed information is already out there somewhere and duplicating it in a tutorial increases the maintenance burden. I&amp;rsquo;d recommend starting with &lt;a href=&#34;http://www.labri.fr/perso/nrougier/teaching/matplotlib/&#34;&gt;Nicolas Rougier&amp;rsquo;s tutorial&lt;/a&gt; over the ones on &lt;a href=&#34;http://matplotlib.org/users/tutorials.html&#34;&gt;matplotlib.org&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m impressed with both tools; they both render beautiful charts. As I mentioned in the intro I&amp;rsquo;d lean towards gnuplot for simpler, quicker tasks since it so convenient and concise, and towards matplotlib for fancier stuff, since it seems like everything imaginable is customizable if you pound your head against the docs for a bit. When each chart is defined in a separate script gnuplot is kicky fast compared to matplotlib, I think largely due to the time it takes to import all the matplotlib libraries; it probably doesn&amp;rsquo;t matter but it still bolsters my warm feelings of convenience for gnuplot.&lt;/p&gt;

&lt;h1 id=&#34;appendix-pandas&#34;&gt;Appendix: pandas&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://pandas.pydata.org/pandas-docs/stable/index.html&#34;&gt;pandas&lt;/a&gt; is a data analysis toolkit for Python and it has some particularly convienient functions for pivoting and rolling up the data. Assuming the times and commands have already been extracted from the datafile as equal-length lists of strings named &lt;code&gt;times&lt;/code&gt; and &lt;code&gt;cmds&lt;/code&gt;, the data can be binned and pivoted into a wide format like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import pandas as pd

df = pd.DataFrame({&#39;cmd&#39;: cmds, &#39;freq&#39;: 1}, index=pd.DatetimeIndex(times))
piv = df.pivot(columns=&#39;cmd&#39;, values=&#39;freq&#39;)
binned = piv.resample(&#39;{}S&#39;.format(seconds)).sum().fillna(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pandas provides a wrapper for matplotlib that works very well for simple cases but isn&amp;rsquo;t flexible enough to make a chart similar to the stacked-bar histograms above. Here&amp;rsquo;s a script where I use matplotlib directly instead: &lt;a href=&#34;http://torbiak.com/post/histogram_gnuplot_vs_matplotlib/shellhist_pandas.py&#34;&gt;shellhist_pandas.py&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;appendix-changelog&#34;&gt;Appendix: changelog&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2017-08-15&lt;/strong&gt;: Added an &lt;a href=&#34;#appendix-pandas&#34;&gt;appendix&lt;/a&gt; discussing the use of &lt;a href=&#34;http://pandas.pydata.org/pandas-docs/stable/index.html&#34;&gt;pandas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2017-10-09&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Added a nice way to make a stacked bar chart for multiple distributions using gnuplot, after discovering the &lt;code&gt;sum [min:max:step] &amp;lt;expr&amp;gt;&lt;/code&gt; syntax.&lt;/li&gt;
&lt;li&gt;Added &lt;code&gt;help&lt;/code&gt; commands to be entered at the gnuplot prompt for easier access to relevant documentation.&lt;/li&gt;
&lt;li&gt;Added the excellent &lt;a href=&#34;https://www.manning.com/books/gnuplot-in-action-second-edition&#34;&gt;Gnuplot in Action&lt;/a&gt; as an important resource for learning gnuplot.&lt;/li&gt;
&lt;li&gt;Removed discussion of colour in gnuplot as it&amp;rsquo;s mostly irrelevant to the task at hand and there&amp;rsquo;s several good ways to change colours that aren&amp;rsquo;t difficult to find. See &lt;code&gt;help colors&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Made the &amp;ldquo;sum&amp;rdquo; line more distinct by making it dotted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2017-10-11&lt;/strong&gt;: Previously I was using the term &amp;ldquo;time series&amp;rdquo; loosely to refer to timestamped data in general, but it usually refers to data that are equally spaced in time. &amp;ldquo;Event stream&amp;rdquo; is more applicable to the data used here.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:using&#34;&gt;A description of the &lt;code&gt;using&lt;/code&gt; clause of the plot command can be found by entering &lt;code&gt;help using&lt;/code&gt; at the gnuplot prompts or in the &amp;ldquo;Commands &amp;gt; Plot &amp;gt; Data &amp;gt; Using&amp;rdquo; section of &lt;a href=&#34;http://gnuplot.info/docs_5.0/gnuplot.pdf&#34;&gt;gnuplot&amp;rsquo;s manual&lt;/a&gt;. The manual is an excellent reference but isn&amp;rsquo;t obviously a tutorial, and before reading most of it I had trouble finding the information I needed. If it was published in HTML I&amp;rsquo;d link directly to relevant sections, but it&amp;rsquo;s only published in PDF so I&amp;rsquo;ve provided section breadcrumbs and &lt;code&gt;help&lt;/code&gt; command keywords.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:using&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:smooth&#34;&gt;&lt;code&gt;help smooth freq&lt;/code&gt; and the &amp;ldquo;Commands &amp;gt; Plot &amp;gt; Data &amp;gt; Smooth &amp;gt; Frequency&amp;rdquo; section of the gnuplot manual have an example of plotting a histogram with the &lt;code&gt;lines&lt;/code&gt; plotting style.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:smooth&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:leap&#34;&gt;Note that one limitation of rounding the epoch seconds time representation like this is that leap seconds aren&amp;rsquo;t taken into account. If leap second accuracy is required for your application a different approach is needed.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:leap&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:time-repr&#34;&gt;See the &amp;ldquo;Gnuplot &amp;gt; Time/Date Data&amp;rdquo; section of the manual or &lt;code&gt;help time/date&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:time-repr&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:sum&#34;&gt;See the &amp;ldquo;Gnuplot &amp;gt; Expressions &amp;gt; Summation&amp;rdquo; section of the manual or &lt;code&gt;help sum&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:sum&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:tzlocal&#34;&gt;&lt;code&gt;dateutil.tz.tzlocal&lt;/code&gt; returns a &lt;code&gt;datetime.tzinfo&lt;/code&gt;-conforming object for the local time zone.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:tzlocal&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:diyfmt&#34;&gt;Alternatively, it&amp;rsquo;s straightforward to stick with Unix times and use &lt;code&gt;matplotlib.dates.FuncFormatter&lt;/code&gt; and &lt;code&gt;MultipleLocator&lt;/code&gt; instead, but I&amp;rsquo;m trying to go with the grain of matplotlib.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:diyfmt&#34;&gt;^&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
      
    
      
    <item>
      <title>Absorb changes across a topic branch in git</title>
      <link>http://torbiak.com/post/autofixup/</link>
      <pubDate>Sun, 04 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/autofixup/</guid>
      <description>

&lt;h1 id=&#34;motivation-tedious-fixups&#34;&gt;Motivation: tedious fixups&lt;/h1&gt;

&lt;p&gt;Here&amp;rsquo;s the situation. I&amp;rsquo;m working on a feature and end up with a chain of commits that depend on each other. It&amp;rsquo;d be easier for me as the author to put all the work in a single commit, but I like telling stories with my commits to (hopefully) make reviewing the branch easier and the history more meaningful in general. Anyway, the review goes back and forth for a while, motivating a bunch of small edits that are logically most connected to various commits. I commit these edits separately and then squash/fixup them all with an interactive rebase. Now, assigning changes to commits representing logical groups of changes was fun/challenging the first time, but assigning these small edits born of review feedback is nearly a mechanical process of scanning through the list of topic branch commits and copy-pasting SHAs. [Or, more conveniently, using &lt;code&gt;git commit --fixup=:/&amp;lt;regex&amp;gt;&lt;/code&gt;, although I haven&amp;rsquo;t thought to do that until recently.]&lt;/p&gt;

&lt;p&gt;Personal and team git workflows apparently vary wildly, so not everyone has dealt with this situation, but I&amp;rsquo;ve encountered it with enough regularity that when I read the description of Facebook&amp;rsquo;s &lt;a href=&#34;https://bitbucket.org/facebook/hg-experimental/src/abee33554ccf744c852b14876d1d2069e3fe22d2/hgext3rd/absorb/__init__.py?at=default&amp;amp;fileviewer=file-view-default&#34;&gt;&lt;code&gt;hg absorb&lt;/code&gt;&lt;/a&gt; command in these &lt;a href=&#34;https://groups.google.com/forum/#!topic/mozilla.dev.version-control/nh4fITFlEMk&#34;&gt;Mercurial sprint notes&lt;/a&gt; I was super envious. To cure my envy I wrote &lt;a href=&#34;https://github.com/torbiak/git-autofixup&#34;&gt;&lt;code&gt;git-autofixup&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-it-works&#34;&gt;How it works&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;git-autofixup&lt;/code&gt; parses hunks of changes in the working directory out of &lt;code&gt;git diff&lt;/code&gt; output and uses &lt;code&gt;git blame&lt;/code&gt; to assign those hunks to commits in &lt;code&gt;&amp;lt;revision&amp;gt;..HEAD&lt;/code&gt;, which will typically represent a topic branch, and then creates fixup commits to be used with &lt;code&gt;git rebase --interactive --autosquash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By default a hunk will be included in a fixup commit if the hunk&amp;rsquo;s context shows there&amp;rsquo;s an unambiguous target topic branch commit. There are two situations where a target commit is considered unambiguous:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When it&amp;rsquo;s the only topic branch commit the hunk is near. More precisely, when it&amp;rsquo;s the only topic branch commit appearing in the blame output of all the hunk&amp;rsquo;s context lines.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s blamed for all the lines that the hunk changed, even if changes from other topic branch commits are nearby. More precisely, it&amp;rsquo;s blamed for all the removed lines and at least one of the context lines adjacent to added lines, and no context lines adjacent to added lines are blamed on any other topic branch commits.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Slightly stricter assignment criteria are also available for when you&amp;rsquo;re untangling fixups from changes for a new commit: see the description of the &lt;code&gt;--strict&lt;/code&gt; option in the &lt;code&gt;--help&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;example&#34;&gt;Example&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;git-autofixup&lt;/code&gt; is most useful on big projects, in big teams, on long-lived topic branches, but I&amp;rsquo;ve tried to concoct a small example that motivates its use. Say we have a little python library that for whatever reason transforms a given name so the letters of the last word of the name alternate between upper and lower case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def last_name_alternating_case(name):
    &amp;quot;&amp;quot;&amp;quot;Return name, but with the last word in aLtErNaTiNg case.&amp;quot;&amp;quot;&amp;quot;
    words = name.split()
    letters = list(words[-1])
    for (i, char) in enumerate(letters):
        if i % 2 == 0:
            letters[i] = char.lower()
        else:
            letters[i] = char.upper()
    words[-1] = &#39;&#39;.join(letters)
    return &#39; &#39;.join(words)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A new function is required that alternates the case of the letters in every other word of a given string, so we start a topic branch and have it track &lt;code&gt;master&lt;/code&gt;. Before we start writing &lt;code&gt;odd_words_alternating_case&lt;/code&gt;, though, we realize some of the logic needed can be factored out of &lt;code&gt;last_name_alternating_case&lt;/code&gt;. So we do that and make a commit with the summary &lt;code&gt;Factor out alternating_case function&lt;/code&gt;. The file is now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def last_name_alternating_case(name):
    &amp;quot;&amp;quot;&amp;quot;Return name, but with the last word in aLtErNaTiNg case.&amp;quot;&amp;quot;&amp;quot;
    words = name.split()
    words[-1] = alternating_case(words[-1])
    return &#39; &#39;.join(words)

def alternating_case(s):
    letters = list(s)
    for (i, char) in enumerate(letters):
        if i % 2 == 0:
            letters[i] = char.upper()
        else:
            letters[i] = char.lower()
    return &#39;&#39;.join(letters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;re ready to write &lt;code&gt;odd_words_alternating_case&lt;/code&gt; using &lt;code&gt;alternating_case&lt;/code&gt;, and commit it as &lt;code&gt;Add odd_words_alternating_case&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def odd_words_alternating_case(s):
    &amp;quot;&amp;quot;&amp;quot;Returns the string with alternating words in alternating case.&amp;quot;&amp;quot;&amp;quot;
    words = s.split()
    for (i, word) in enumerate(words):
        if i % 2 == 0:
            continue
        words[i] = alternating_case(word)
    return &#39; &#39;.join(words)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking the code over, we realize we want to give &lt;code&gt;alternating_case&lt;/code&gt; a docstring, change the tense/mood of the &lt;code&gt;odd_words_alternating_case&lt;/code&gt; docstring so it&amp;rsquo;s consistent with &lt;code&gt;last_name_alternating_case&lt;/code&gt;, and we decide the first character of alternating-case words should be uppercase. Here&amp;rsquo;s the diff of these unstaged changes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/ex.py b/ex.py
index 2ed7e63..2a5e73b 100644
--- a/ex.py
+++ b/ex.py
@@ -7,2 +7,3 @@ def last_name_alternating_case(name):
 def alternating_case(s):
+    &amp;quot;&amp;quot;&amp;quot;Return s with its characters in aLtErNaTiNg case.&amp;quot;&amp;quot;&amp;quot;
     letters = list(s)
@@ -10,5 +11,5 @@ def alternating_case(s):
         if i % 2 == 0:
-            letters[i] = char.upper()
-        else:
             letters[i] = char.lower()
+        else:
+            letters[i] = char.upper()
     return &#39;&#39;.join(letters)
@@ -16,3 +17,3 @@ def alternating_case(s):
 def odd_words_alternating_case(s):
-    &amp;quot;&amp;quot;&amp;quot;Returns the string with alternating words in alternating case.&amp;quot;&amp;quot;&amp;quot;
+    &amp;quot;&amp;quot;&amp;quot;Return s with odd words in alternating case.&amp;quot;&amp;quot;&amp;quot;
     words = s.split()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;d like to squash these changes into the previous two commits. In this particular instance it&amp;rsquo;d be quite easy to do with two rounds of &lt;code&gt;git add --patch&lt;/code&gt; followed by &lt;code&gt;git commit --fixup=:/&amp;lt;regex&amp;gt;&lt;/code&gt;. but if the topic branch had more commits and we were fixing up more areas this process would get tedious. Let&amp;rsquo;s see what &lt;code&gt;git-autofixup&lt;/code&gt; does with it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git-autofixup -vv @{upstream}
ex.py @@ -5,16 +5,17 @@ has multiple targets
656a790f|   5|    return &#39; &#39;.join(words)    |     return &#39; &#39;.join(words)
656a790f|   6|                              |
656a790f|   7|def alternating_case(s):      | def alternating_case(s):
        |    |                              |+    &amp;quot;&amp;quot;&amp;quot;Return s with its char
656a790f|   8|    letters = list(s)         |     letters = list(s)
^       |   9|    for (i, char) in enumerate|     for (i, char) in enumerat
^       |  10|        if i % 2 == 0:        |         if i % 2 == 0:
^       |  11|            letters[i] = char.|-            letters[i] = char
656a790f|  12|        else:                 |-        else:
656a790f|  13|            letters[i] = char.|             letters[i] = char
        |    |                              |+        else:
        |    |                              |+            letters[i] = char
656a790f|  14|    return &#39;&#39;.join(letters)   |     return &#39;&#39;.join(letters)
5be3a3b9|  15|                              |
5be3a3b9|  16|def odd_words_alternating_case| def odd_words_alternating_cas
5be3a3b9|  17|    &amp;quot;&amp;quot;&amp;quot;Returns the string with|-    &amp;quot;&amp;quot;&amp;quot;Returns the string wit
        |    |                              |+    &amp;quot;&amp;quot;&amp;quot;Return s with odd word
5be3a3b9|  18|    words = s.split()         |     words = s.split()
5be3a3b9|  19|    for (i, word) in enumerate|     for (i, word) in enumerat
5be3a3b9|  20|        if i % 2 == 0:        |         if i % 2 == 0:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re using high verbosity (&lt;code&gt;-vv&lt;/code&gt;) so that the &amp;ldquo;blamediff&amp;rdquo; gets printed and we can see how the hunks are being handled. Our changes are close enough together that they all get put into the same hunk with the default number of diff context lines (3), and then that single hunk is related to both of our topic branch commits. When we reduce the number of context lines to get more hunks the unstaged changes are isolated enough to be assigned to their respective commits and two &lt;code&gt;fixup!&lt;/code&gt; commits are created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git-autofixup --context=1 -vv @{upstream}
ex.py @@ -7,2 +7,3 @@ fixes 656a790f Factor out alternating_case function
656a790f|   7|def alternating_case(s):      | def alternating_case(s):
        |    |                              |+    &amp;quot;&amp;quot;&amp;quot;Return s with its char
656a790f|   8|    letters = list(s)         |     letters = list(s)

ex.py @@ -10,5 +11,5 @@ fixes 656a790f Factor out alternating_case function
^       |  10|        if i % 2 == 0:        |         if i % 2 == 0:
^       |  11|            letters[i] = char.|-            letters[i] = char
656a790f|  12|        else:                 |-        else:
656a790f|  13|            letters[i] = char.|             letters[i] = char
        |    |                              |+        else:
        |    |                              |+            letters[i] = char
656a790f|  14|    return &#39;&#39;.join(letters)   |     return &#39;&#39;.join(letters)

ex.py @@ -16,3 +17,3 @@ fixes 5be3a3b9 Add odd_word_alternating_case function
5be3a3b9|  16|def odd_words_alternating_case| def odd_words_alternating_cas
5be3a3b9|  17|    &amp;quot;&amp;quot;&amp;quot;Returns the string with|-    &amp;quot;&amp;quot;&amp;quot;Returns the string wit
        |    |                              |+    &amp;quot;&amp;quot;&amp;quot;Return s with odd word
5be3a3b9|  18|    words = s.split()         |     words = s.split()

[topic 44cadf7] fixup! Add odd_word_alternating_case function
 1 file changed, 1 insertion(+), 1 deletion(-)
[topic bde4ca5] fixup! Factor out alternating_case function
 1 file changed, 3 insertions(+), 2 deletions(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we do a &lt;code&gt;git rebase --interactive --autosquash&lt;/code&gt; and see git has set the fixup commits to be squashed into their targets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick 656a790 Factor out alternating_case function
fixup cfa466e fixup! Factor out alternating_case function
pick 5be3a3b Add odd_word_alternating_case function
fixup 1a6c084 fixup! Add odd_word_alternating_case function
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;where-to-get-it&#34;&gt;Where to get it&lt;/h1&gt;

&lt;p&gt;Check it out on &lt;a href=&#34;https://github.com/torbiak/git-autofixup&#34;&gt;GitHub&lt;/a&gt; or the &lt;a href=&#34;https://metacpan.org/pod/distribution/App-Git-Autofixup/git-autofixup&#34;&gt;CPAN&lt;/a&gt;. It can be installed using a CPAN client or by simply downloading the self-contained script, &lt;a href=&#34;https://raw.githubusercontent.com/torbiak/git-autofixup/master/git-autofixup&#34;&gt;&lt;code&gt;git-autofixup&lt;/code&gt;&lt;/a&gt;, to a directory in &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
      
    
      
    <item>
      <title>Finding find: grasping its simple expression language</title>
      <link>http://torbiak.com/post/finding_find/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/finding_find/</guid>
      <description>

&lt;h1 id=&#34;confusion&#34;&gt;Confusion&lt;/h1&gt;

&lt;p&gt;I remember the first time I tried to use the &lt;code&gt;find&lt;/code&gt; command on Linux, over a decade ago. I knew a substring of the name of a file I wanted to find, had found something on the web suggesting I use &lt;code&gt;find&lt;/code&gt;, and was so disappointed when I couldn&amp;rsquo;t just run &lt;code&gt;find $SUBSTR&lt;/code&gt; to get my desired result. &amp;ldquo;Surely such a command exists,&amp;rdquo; I thought. And it basically does, with &lt;code&gt;locate&lt;/code&gt;, but I was searching directories that hadn&amp;rsquo;t been indexed by &lt;code&gt;updatedb&lt;/code&gt; and didn&amp;rsquo;t know enough about globbing and quoting in &lt;code&gt;bash&lt;/code&gt; to effectively give patterns to it. So I did some more searching on the web, learned I needed to give a &lt;code&gt;-name&lt;/code&gt; predicate to &lt;code&gt;find&lt;/code&gt;, and typed a lot of commands like the following over the next few years:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -name &amp;quot;*$SUBSTR*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[Here I&amp;rsquo;m using &amp;ldquo;predicate&amp;rdquo; to mean a term of an expression. It&amp;rsquo;s the word the GNU manpage uses.]&lt;/p&gt;

&lt;p&gt;Much later, after reading the bash manpage a few times, among other things, I wrote a shell function to make this specific task a bit shorter to type, giving me the command I had wished for years before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# find files under current directory containing a pattern
function ff {
    pattern=${1:?No pattern given}; shift
    find . -iname &amp;quot;*${pattern}*&amp;quot; &amp;quot;$@&amp;quot; 2&amp;gt;/dev/null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;beyond-names&#34;&gt;Beyond names&lt;/h1&gt;

&lt;p&gt;Eventually I needed to find files based on their modification times and I started using the &lt;code&gt;-mtime&lt;/code&gt; predicate. For example, to find files modified within the past 24 hours (&lt;code&gt;-mtime&lt;/code&gt; takes units of 24 hours):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using a condition like this that can match large numbers of uninteresting files it becomes obvious that further filtering is necessary. &lt;code&gt;egrep -v&lt;/code&gt; can be used for this, but to avoid needlessly traversing directories and wasting time, using the &lt;code&gt;-prune&lt;/code&gt; predicate for &lt;code&gt;find&lt;/code&gt; is desirable. It was difficult to use properly without understanding find&amp;rsquo;s little expression language, though.&lt;/p&gt;

&lt;h1 id=&#34;essence-of-expressions&#34;&gt;Essence of expressions&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;DESCRIPTION&lt;/code&gt; in the manpage for GNU &lt;code&gt;find&lt;/code&gt; makes sense now but it meant nothing to me in 2005. &amp;ldquo;&amp;hellip;evaluating the given expression from left to right, according to the rules of precedence, until the outcome is known, at which point &lt;code&gt;find&lt;/code&gt; moves on to the next file name.&amp;rdquo; All it means, though, is that you give &lt;code&gt;find&lt;/code&gt; a boolean expression composed of predicates and operators, and each file will get tested against it. Each predicate evaluates to true or false, and they are combined with the AND (&lt;code&gt;-a&lt;/code&gt;) and OR (&lt;code&gt;-o&lt;/code&gt;) operators. I don&amp;rsquo;t remember how I came to understand this, but the best explanation I&amp;rsquo;ve seen is in chapter 9 of &lt;a href=&#34;http://shop.oreilly.com/product/9780596003302.do&#34;&gt;Unix Power Tools&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A few pages down in the manpage, in the &lt;code&gt;EXPRESSION&lt;/code&gt; section, we see there are several classes of predicates: tests, actions, options, and operators. &lt;code&gt;-mtime&lt;/code&gt; and &lt;code&gt;-name&lt;/code&gt; are examples of tests, &lt;code&gt;-print&lt;/code&gt; is the default action, &lt;code&gt;-maxdepth&lt;/code&gt; is an example of an option, and &lt;code&gt;-a&lt;/code&gt; (AND) is the default operator. It might seem weird to include actions and options in a boolean expression of tests, and it is, but it works well. They can be shoehorned in with the tests because they also return boolean values: most &lt;em&gt;actions&lt;/em&gt; always return true, and &lt;em&gt;options&lt;/em&gt; always return true. &lt;code&gt;-print&lt;/code&gt;, the most commonly used action, always returns true.&lt;/p&gt;

&lt;p&gt;After grasping this key point, that &lt;code&gt;find&lt;/code&gt; is just evaluating a boolean expression, it&amp;rsquo;s easy to write elaborate commands. Starting with something simple, though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
bar  foo
$ find . -name foo -a -print
./foo

# Using defaults to save typing:
$ find . -name foo
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This expression and its evaluation can be represented in a C-inspired syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Testing &amp;quot;bar&amp;quot;:
name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print
false &amp;amp;&amp;amp; print
false
continue to the next file

Testing &amp;quot;foo&amp;quot;:
name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print
true &amp;amp;&amp;amp; print
print
true
continue to the next file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;find&lt;/code&gt; reads the current directory, gets &lt;code&gt;bar&lt;/code&gt;, tests it against &lt;code&gt;-name foo&lt;/code&gt;, which evaluates to false, and short-circuits on the &lt;code&gt;-a&lt;/code&gt; operator, continuing on to &lt;code&gt;foo&lt;/code&gt;, which tests true with &lt;code&gt;-name foo&lt;/code&gt; and so gets printed by &lt;code&gt;-print&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;prune&#34;&gt;Prune&lt;/h1&gt;

&lt;p&gt;Back to &lt;code&gt;-prune&lt;/code&gt;. We&amp;rsquo;re still searching for &lt;code&gt;foo&lt;/code&gt;, but let&amp;rsquo;s say there&amp;rsquo;s also a directory we don&amp;rsquo;t want to descend into called &lt;code&gt;cache&lt;/code&gt;. There&amp;rsquo;s a file called &lt;code&gt;foo&lt;/code&gt; in it so it&amp;rsquo;s easier to tell if it&amp;rsquo;s getting searched.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# List files (-type f) under the working directory.
$ find . -type f
./cache/foo
./bar
./foo

$ find . -name cache -prune -o -name foo -print
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the expression in C-inspired syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Testing &amp;quot;cache&amp;quot;:
(name == &amp;quot;cache&amp;quot; &amp;amp;&amp;amp; prune) || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
(true &amp;amp;&amp;amp; prune) || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
prune || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
true || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
true
continue to the next file

Testing &amp;quot;foo&amp;quot;:
(name == &amp;quot;cache&amp;quot; &amp;amp;&amp;amp; prune) || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
(false &amp;amp;&amp;amp; prune) || (name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print)
name == &amp;quot;foo&amp;quot; &amp;amp;&amp;amp; print
true &amp;amp;&amp;amp; print
print
true
continue to the next file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s run through this. When &lt;code&gt;find&lt;/code&gt; is testing &lt;code&gt;cache&lt;/code&gt;, &lt;code&gt;-name cache&lt;/code&gt; returns true, so &lt;code&gt;-prune&lt;/code&gt; gets run, which removes &lt;code&gt;cache&lt;/code&gt; from the list of directories to descend into and returns true. The return value of the whole expression is then known because the left side of the OR (&lt;code&gt;-o&lt;/code&gt;) is true, so &lt;code&gt;find&lt;/code&gt; moves onto the next file. When testing &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;-name cache&lt;/code&gt; returns false, failing the left side of the OR, so &lt;code&gt;find&lt;/code&gt; moves to the right side where &lt;code&gt;-name foo&lt;/code&gt; returns true, resulting in &lt;code&gt;./foo&lt;/code&gt; being printed.&lt;/p&gt;

&lt;h1 id=&#34;default-action&#34;&gt;Default action&lt;/h1&gt;

&lt;p&gt;If an expression doesn&amp;rsquo;t print or execute anything &lt;code&gt;find&lt;/code&gt; treats it as if it were surrounded in parentheses and followed by a print action: &lt;code&gt;( EXPR ) -print&lt;/code&gt;. For example, if we remove &lt;code&gt;-print&lt;/code&gt; from the previous command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -name cache -prune -o -name foo
./cache
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cache&lt;/code&gt; gets printed because &lt;code&gt;-prune&lt;/code&gt; returns true, making the overall expression true for it.&lt;/p&gt;

&lt;h1 id=&#34;parens&#34;&gt;Parens&lt;/h1&gt;

&lt;p&gt;As with many expression languages, parentheses can be used to force precedence. They need to be escaped or quoted so the shell doesn&amp;rsquo;t treat them specially:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -name cache -prune -o \( -name foo -o -name bar \) -print
./bar
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h1&gt;

&lt;p&gt;If an expression isn&amp;rsquo;t behaving as expected &lt;code&gt;-exec&lt;/code&gt; or &lt;code&gt;-printf&lt;/code&gt; can be used to visualize what&amp;rsquo;s actually happening. If portability is important, note that &lt;code&gt;-printf&lt;/code&gt; is a GNU extension and isn&amp;rsquo;t specified in &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html&#34;&gt;POSIX&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -name cache -printf &amp;quot;pruning %p\n&amp;quot; -prune -o -name foo -print
pruning ./cache
./foo

$ find . -name cache -exec echo pruning {} \; -prune -o -name foo -print
pruning ./cache
./foo
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;there-s-more&#34;&gt;There&amp;rsquo;s more&lt;/h1&gt;

&lt;p&gt;Once I understood the basic concept of the expression language the manpage became a good reference. Check it out to discover other useful tests and actions. Some of my favourite POSIX-specified predicates are &lt;code&gt;-perm&lt;/code&gt;, &lt;code&gt;-user&lt;/code&gt;, and &lt;code&gt;-size&lt;/code&gt;, and I frequently use the GNU extensions &lt;code&gt;-maxdepth&lt;/code&gt;, &lt;code&gt;-mmin&lt;/code&gt;, &lt;code&gt;-regex&lt;/code&gt;, and &lt;code&gt;-ls&lt;/code&gt;. Happy finding.&lt;/p&gt;
</description>
    </item>
      
    
      
    <item>
      <title>Failing to write useful mouse keys for X11</title>
      <link>http://torbiak.com/post/failing_mouse_keys/</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/failing_mouse_keys/</guid>
      <description>

&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve stuck with Apple laptops primarily because I haven&amp;rsquo;t had a pleasant trackpad experience on anything else. But about a year ago I noticed I was spending all my time in a web browser and tmux and had disabled or was avoiding many of OSX&amp;rsquo;s features, like the Dock, Dashboard, full-screen apps (due to the lengthy animations), Spotlight (because &lt;code&gt;mdworker&lt;/code&gt; indexing processes have a history of going out of control and pinning CPUs), and iTunes. So I thought I might as well switch to Linux and the &lt;a href=&#34;http://suckless.org&#34;&gt;suckless.org&lt;/a&gt; desktop (&lt;code&gt;dwm&lt;/code&gt;, &lt;code&gt;dmenu&lt;/code&gt;, &lt;code&gt;st&lt;/code&gt;), as long as I could get the trackpad working well enough.&lt;/p&gt;

&lt;p&gt;Initially I had the synaptics touchpad driver installed, but after several hours of fruitless tweaking I gave up on making a usable configuration. It seemed impossible to get enough sensitivity while also adequately ignoring accidental touches using the given configuration parameters. So I tried the evdev and libinput drivers and thankfully the libinput driver gives very acceptable behaviour, though it&amp;rsquo;s still a ways off from the magic of Apple&amp;rsquo;s driver, which has never failed to behave as expected when pointing or scrolling.&lt;/p&gt;

&lt;p&gt;Anyway, all this fussing over trackpads made me wonder if controlling the pointer using the keyboard could be a better experience. An efficient enough mouse keys implementation could also be useful for people with trackpad-specific repetitive strain injuries, or in the admittedly rare situations where both a trackpad and mouse are unavailable or infeasible, like if you wanted to control a media PC with only a keyboard.&lt;/p&gt;

&lt;h1 id=&#34;existing-solution&#34;&gt;Existing solution&lt;/h1&gt;

&lt;p&gt;I tried out the keypad pointer keys in X11 (&lt;code&gt;setxkbmap -option keypad:pointerkeys&lt;/code&gt;), but they aren&amp;rsquo;t fluid when changing direction and it&amp;rsquo;s a pain to set up pointer keys on keys other than the keypad. Worst of all, accelerating the pointer after a movement key has been pressed down for a while is counter to how I usually point at things: flinging the pointer over to the general area of my target before carefully zeroing in on it. So I started writing my own, calling it &lt;a href=&#34;https://github.com/torbiak/ptrkeys&#34;&gt;&lt;code&gt;ptrkeys&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;inspiration&#34;&gt;Inspiration&lt;/h1&gt;

&lt;p&gt;Having decided acceleration was the wrong way to make mouse keys efficient, I tried out some schemes where the speed could be changed instantly. My first idea was to have &amp;ldquo;dual-sticks&amp;rdquo;, two sets of directional keys, one for coarse and the other for fine control, but this was surprisingly difficult to use. It was far more intuitive to use WASD for directional control while using the thumb and pinky or the other hand to change the speed using speed multiplier keys.&lt;/p&gt;

&lt;p&gt;dwm served as a model for most of the Xlib interactions I needed to do. Its method of defining X11 key bindings at compile time using C99 struct initializations is surprisingly simple and flexible, and using a similar method has allowed me to try out totally different binding schemes with minimal changes.&lt;/p&gt;

&lt;p&gt;The tricky part was understanding exactly how X11 keyboard grabs work. X generally directs keyboard events to the focused window, but a keyboard can be &amp;ldquo;grabbed&amp;rdquo; as a whole or on a per-key basis so that its events are sent elsewhere. For example, pressing a key implicitly sets up a single-key grab so the subsequent release event is received by the same window that got the keypress. ptrkeys doesn&amp;rsquo;t create a window that can be focused, so a single-key grab is necessary to setup a &amp;ldquo;global hotkey&amp;rdquo; that can be used to enable ptrkeys by grabbing the entire keyboard and thus &amp;ldquo;activating&amp;rdquo; the rest of its configured key bindings.&lt;/p&gt;

&lt;h1 id=&#34;downfall&#34;&gt;Downfall&lt;/h1&gt;

&lt;p&gt;Grabs also ended up being the downfall of the project: any full-featured desktop environment grabs the whole keyboard when opening a menu for a taskbar, menubar, or system tray, so that it can be navigated with the keyboard without changing the currently focused window. If ptrkeys already has the keyboard grabbed, the desktop environment&amp;rsquo;s attempt to grab it fails and the menu typically doesn&amp;rsquo;t open. This severely limits the applicability of ptrkeys. And it doesn&amp;rsquo;t seem like there&amp;rsquo;s a way around grabbing the whole keyboard either since a single-key grab becomes a whole-keyboard grab while it&amp;rsquo;s active.&lt;/p&gt;

&lt;p&gt;So, while &lt;code&gt;ptrkeys&lt;/code&gt; likely isn&amp;rsquo;t useful for anyone using a desktop environment like GNOME, KDE, or XFCE, it might be for those using tiling window managers. &lt;a href=&#34;https://github.com/torbiak/ptrkeys&#34;&gt;Check it out on github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
      
    
      
    <item>
      <title>File management on Windows with Proto</title>
      <link>http://torbiak.com/post/proto/</link>
      <pubDate>Mon, 06 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://torbiak.com/post/proto/</guid>
      <description>

&lt;p&gt;Dissatisfied with &lt;code&gt;explorer.exe&lt;/code&gt;? Find drag-and-drop and manual window placement tedious? Like using the keyboard? Don&amp;rsquo;t want to choose between the hundreds of Norton Commander clones? You should try &lt;a href=&#34;http://miechu.pl/proto/&#34;&gt;Proto&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Proto is a fast, weird, original, keyboard-controlled file manager written by Mieszko Lassota. You get tabs, incremental subsequence filtering everywhere (eg. &amp;lsquo;mp3&amp;rsquo; matches things like &amp;lsquo;my panda &amp;lt;3&amp;rsquo; and &amp;lsquo;badtimes.mp3&amp;rsquo;), renaming using regexes, an application launcher, and a nifty way to select groups of files, even if they&amp;rsquo;re across filters or directories.&lt;/p&gt;

&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;

&lt;p&gt;Proto doesn&amp;rsquo;t seem to use the registry so just put it somewhere comfortable and run the executable.&lt;/p&gt;

&lt;h1 id=&#34;help&#34;&gt;Help&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;re on Windows, so press &lt;strong&gt;F1&lt;/strong&gt; to get help in the form of key bindings for the current tab. There are different types of tabs, like file manager, program launcher, calculator, etc., and help is context sensitive, bringing up the commands for the current tab. Type some characters to filter the commands. Press &lt;strong&gt;Escape&lt;/strong&gt; to escape help.&lt;/p&gt;

&lt;p&gt;Unlike in most of the other tab types which filter by subsequence, in help filtering is done by substring.&lt;/p&gt;

&lt;h1 id=&#34;invoke&#34;&gt;Invoke&lt;/h1&gt;

&lt;p&gt;Once it&amp;rsquo;s running you can call up the Proto window by pressing &lt;strong&gt;Alt-`&lt;/strong&gt; (that&amp;rsquo;s a backtick). This key can be changed in &lt;code&gt;$PROTODIR/Settings/Proto.xml&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;tabs&#34;&gt;Tabs&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-t&lt;/strong&gt; opens a new file manager tab. &lt;strong&gt;Ctrl-shift-t&lt;/strong&gt; duplicates the current tab. &lt;strong&gt;Shift-return&lt;/strong&gt; opens a directory in a new tab.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-w&lt;/strong&gt; closes a tab.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-tab&lt;/strong&gt;, &lt;strong&gt;ctrl-shift-tab&lt;/strong&gt;, &lt;strong&gt;ctrl-&amp;lt;arrow&amp;gt;&lt;/strong&gt;, and &lt;strong&gt;ctrl-&amp;lt;number&amp;gt;&lt;/strong&gt; let you select tabs. &lt;strong&gt;Ctrl-shift-&amp;lt;arrow&amp;gt;&lt;/strong&gt; reorders a tab.&lt;/p&gt;

&lt;h1 id=&#34;navigate&#34;&gt;Navigate&lt;/h1&gt;

&lt;p&gt;Use the arrow keys to change which item in the tab is highlighted. To descend into a highlighted directory, press &lt;strong&gt;enter&lt;/strong&gt;. Press &lt;strong&gt;backspace&lt;/strong&gt; to go up a directory. Pressing &lt;strong&gt;enter&lt;/strong&gt; will also open a highlighted file with its default program. Press &lt;strong&gt;tab&lt;/strong&gt; to bring up the launcher and open the highlighted item with a different program. If any items are selected they will be opened instead of the highlighted item.&lt;/p&gt;

&lt;h1 id=&#34;select&#34;&gt;Select&lt;/h1&gt;

&lt;p&gt;Selected items are prepended by a bullet. If no items are selected the currently highlighted item is used as the selection for commands that take a filepath.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Space&lt;/strong&gt; selects the currently highlighted item. &lt;strong&gt;Ctrl-a&lt;/strong&gt; selects all the items, and pressing it again when everying is already selected deselects everything.  &lt;strong&gt;Alt-a&lt;/strong&gt; toggles between selecting all files and directories. &lt;strong&gt;Shift-down&lt;/strong&gt; selects the current item and highlights the next one. &lt;strong&gt;Shift-right&lt;/strong&gt; behaves similarly, but on columns.&lt;/p&gt;

&lt;h1 id=&#34;filtering&#34;&gt;Filtering&lt;/h1&gt;

&lt;p&gt;You can type a few characters to filter the contents of a tab using subsequence search. &lt;strong&gt;Backspace&lt;/strong&gt; does what you&amp;rsquo;d expect. &lt;strong&gt;Ctrl-Backspace&lt;/strong&gt; clears the filter. You can&amp;rsquo;t usually have spaces in your filter because the space key selects the current item in the tab.&lt;/p&gt;

&lt;h1 id=&#34;file-management&#34;&gt;File management&lt;/h1&gt;

&lt;p&gt;Cut, copy, and paste behave differently in Proto than they do in Explorer. Copy (&lt;strong&gt;Ctrl-c&lt;/strong&gt;) puts filepaths in the clipboard, and then the clipboard is used as input for the cut and paste commands. Cut (&lt;strong&gt;Ctrl-x&lt;/strong&gt;) moves the files in the clipboard to the tab&amp;rsquo;s current location, while paste (&lt;strong&gt;Ctrl-v&lt;/strong&gt;) copies files. So instead of choosing up front whether you&amp;rsquo;re going to move or copy files like in Explorer, in Proto you first choose which paths you want to work with, and then choose whether to copy or move after navigating to the destination.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alt-c&lt;/strong&gt; appends the selection to the clipboard.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Delete&lt;/strong&gt; deletes the selection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-n&lt;/strong&gt; creates a new directory. &lt;strong&gt;Ctrl-space&lt;/strong&gt; displays the size of the selection in the lower right.&lt;/p&gt;

&lt;h1 id=&#34;rename&#34;&gt;Rename&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-r&lt;/strong&gt; lets you rename the highlighted item. &lt;strong&gt;Ctrl-Shift-r&lt;/strong&gt; lets you rename the selection using regular expressions. Captured groups can be accessed in the replacement using &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.&lt;/p&gt;

&lt;h1 id=&#34;launcher&#34;&gt;Launcher&lt;/h1&gt;

&lt;p&gt;The launcher can be invoked from inside or outside of Proto using &lt;strong&gt;Alt-space&lt;/strong&gt;. To get Proto to index the Start Menu so the launcher is useful, ensure &lt;code&gt;settings.links.indexMenuStart&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; in &lt;code&gt;$PROTODIR/Settings/AppLauncher.xml&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;bookmarks&#34;&gt;Bookmarks&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Alt-1&lt;/strong&gt; opens a tab of bookmarks to your favourite directories and files. &lt;strong&gt;Ctrl-b&lt;/strong&gt; adds a bookmark to the highlighted directory.&lt;/p&gt;

&lt;h1 id=&#34;find&#34;&gt;Find&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Ctrl-f&lt;/strong&gt; searches recursively for files using wildcards (&lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;) or regular expressions.&lt;/p&gt;

&lt;p&gt;The grep (&amp;ldquo;Regex search IN files&amp;rdquo;) function doesn&amp;rsquo;t seem to work, unfortunately. It always crashes for me.&lt;/p&gt;

&lt;h1 id=&#34;other-shortcuts-i-use&#34;&gt;Other shortcuts I use&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-s&lt;/strong&gt;: Change sort key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-.&lt;/strong&gt;: Open the windows context menu.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-End&lt;/strong&gt;: Kill proto job, such as calculating file size. The current job shows up in the lower left corner of the Proto window.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-h&lt;/strong&gt;: edit text file, quickview image (use arrows for folder slideshow)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl-g&lt;/strong&gt;: disk space chart&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
      
    
  </channel>
</rss>
